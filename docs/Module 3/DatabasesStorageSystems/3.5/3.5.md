---
title: Database Sharding
sidebar_label: "3.5 Database Sharding"
description: Understanding database sharding, sharding strategies, and how sharding enables horizontal database scalability
---

# Database Sharding

> Goal: Understand how sharding works, why it is needed, and how different sharding strategies affect scalability, performance, and complexity.

---

## 3.5.1 What Is Database Sharding?

**Database sharding** is the process of:
- **Splitting data** across multiple database nodes
- Each node stores **only a subset** of the data
- Together, all shards form the complete dataset

```mermaid
graph LR
    App --> Shard1[(Shard 1)]
    App --> Shard2[(Shard 2)]
    App --> Shard3[(Shard 3)]
````

> Sharding scales **writes and data size** by distributing load.

---

## 3.5.2 Why Do We Need Sharding?

Replication alone cannot:

* Scale writes
* Handle very large datasets

### Problems Without Sharding

* Single primary becomes write bottleneck
* Storage limits reached
* High contention

> **Replication scales reads.
> Sharding scales writes and data.**

---

## 3.5.3 Sharding vs Replication (Quick Recap)

| Aspect        | Replication         | Sharding                    |
| ------------- | ------------------- | --------------------------- |
| Purpose       | Availability, reads | Scalability (writes & data) |
| Data          | Same data copied    | Data split                  |
| Write scaling | âŒ No                | âœ… Yes                       |
| Complexity    | Lower               | Higher                      |

---

## 3.5.4 Shard Key (MOST IMPORTANT) â­â­â­â­â­

### What Is a Shard Key?

A **shard key** determines:

* Which shard stores a given record
* How evenly data & load are distributed

```text
shard_id = hash(shard_key) % number_of_shards
```

### Examples

* `user_id`
* `order_id`
* `customer_id`

> **Choosing the wrong shard key is the #1 sharding mistake.**

---

## 3.5.5 Range-Based Sharding â­â­â­â­

### How It Works

Data is split by **ranges** of the shard key.

Example:

* Shard 1 â†’ users 1â€“1,000
* Shard 2 â†’ users 1,001â€“2,000

```mermaid
graph TD
    Users -->|1â€“1000| Shard1
    Users -->|1001â€“2000| Shard2
```

### Pros

* Simple
* Efficient range queries

### Cons

* **Hot shards**
* Uneven load

---

## 3.5.6 Hash-Based Sharding â­â­â­â­â­

### How It Works

Shard determined by hashing the shard key.

```mermaid
graph LR
    Key --> Hash --> Shard
```

### Pros

* Even data distribution
* Avoids hot shards

### Cons

* Range queries are hard
* Resharding is expensive

> Most large-scale systems use **hash-based sharding**.

---

## 3.5.7 Consistent Hashing â­â­â­â­â­ (VERY IMPORTANT)

### Problem with Normal Hashing

Adding/removing shards causes **massive data movement**.

### Solution: Consistent Hashing

* Shards placed on a hash ring
* Only a small portion of data moves

```mermaid
graph TD
    Ring[Hash Ring]
    S1[Shard 1]
    S2[Shard 2]
    S3[Shard 3]

    Ring --> S1
    Ring --> S2
    Ring --> S3
```

### Benefits

* Easier scaling
* Minimal rebalancing

---

## 3.5.8 Directory-Based Sharding â­â­â­

### How It Works

* A lookup service maps keys â†’ shards

```mermaid
graph LR
    App --> Directory
    Directory --> Shard1
    Directory --> Shard2
```

### Pros

* Flexible
* Easy re-mapping

### Cons

* Directory is a SPOF
* Extra hop

---

## 3.5.9 Sharding & Query Routing

The application must:

* Know the shard key
* Route queries to the correct shard

```mermaid
sequenceDiagram
    App->>Router: Query(user_id=123)
    Router->>Shard2: Execute query
```

> Cross-shard queries are **expensive**.

---

## 3.5.10 Cross-Shard Queries & Joins â­â­â­â­

### Problem

* Joins across shards are slow
* Requires querying multiple shards

### Solutions

* Denormalization
* Scatter-gather queries
* Avoid cross-shard joins

> **Design queries around the shard key.**

---

## 3.5.11 Resharding Challenges â­â­â­â­â­

Resharding happens when:

* Data grows
* Traffic increases
* Shards become imbalanced

### Challenges

* Data movement
* Downtime risk
* Consistency during migration

> Resharding is **hard and risky**.

---

## 3.5.12 Sharding & Consistency

* Single shard â†’ strong consistency possible
* Multi-shard transactions â†’ very complex
* Often avoided or handled via application logic

> Distributed transactions + sharding = pain ğŸ˜„

---

## 3.5.13 Sharding in a Payment System (Example)

* Shard by `user_id`
* Each shard handles its usersâ€™ transactions
* Global reports handled asynchronously

```mermaid
graph LR
    PaymentService --> ShardA
    PaymentService --> ShardB
```

---

## 3.5.14 Common Interview Mistakes âŒ

âŒ Confusing replication with sharding
âŒ Choosing timestamp as shard key
âŒ Ignoring resharding
âŒ Assuming joins are easy

âœ… Correct thinking:

* Shard by access pattern
* Avoid cross-shard operations
* Plan for growth early

---

## Key Takeaways â­â­â­â­â­

* Sharding splits data
* Enables write & data scalability
* Shard key choice is critical
* Hash-based sharding is common
* Resharding is complex and risky

---

## Interview-Ready One-Liners â­

* â€œReplication scales reads; sharding scales writes.â€
* â€œShard key choice defines system scalability.â€
* â€œCross-shard joins are expensive.â€
* â€œConsistent hashing minimizes data movement.â€

---

## References & Deep-Dive Resources

### Articles

* [https://www.geeksforgeeks.org/database-sharding/](https://www.geeksforgeeks.org/database-sharding/)
* [https://aws.amazon.com/what-is/database-sharding/](https://aws.amazon.com/what-is/database-sharding/)
* [https://martinfowler.com/articles/patterns-of-distributed-systems/](https://martinfowler.com/articles/patterns-of-distributed-systems/)

### Videos

* [https://www.youtube.com/watch?v=E8vS0xNqzXU](https://www.youtube.com/watch?v=E8vS0xNqzXU) (Sharding Explained)
* [https://www.youtube.com/watch?v=ZQp9dHqH0L0](https://www.youtube.com/watch?v=ZQp9dHqH0L0) (Consistent Hashing)

### Books

* *Designing Data-Intensive Applications* â€“ Martin Kleppmann
* *Database Internals* â€“ Alex Petrov

---

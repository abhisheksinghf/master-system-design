---
title: Scalability Basics
sidebar_label: "1.2 Scalability Basics"
description: Foundations of scalability, load patterns, bottlenecks, and growth strategies.
---

## 1.2.1 What Is Scalability?

**Scalability** is a systemâ€™s ability to handle:
- More users
- More requests
- More data

without:
- Performance degradation
- Major redesign

> A system that works for 100 users but fails at 10,000 users is **not scalable**.

---

## 1.2.2 Why Scalability Matters

Real-world reality:
- User growth is unpredictable
- Traffic spikes happen
- Marketing campaigns break systems ğŸ˜„

Good scalability:
- Handles growth smoothly
- Costs less long-term

---

## 1.2.3 Types of Scaling â­â­â­â­â­

### Vertical Scaling (Scale Up)

Add more resources to one machine:
- More CPU
- More RAM
- Bigger disk

```mermaid
graph TD
    S[Server] --> S2[More CPU/RAM]
````

#### Pros

* Simple
* No code changes

#### Cons

* Hardware limits
* Single Point of Failure
* Expensive

---

### Horizontal Scaling (Scale Out) â­â­â­â­â­

Add more machines:

* More servers
* Same code

```mermaid
graph LR
    LB[Load Balancer] --> S1[Server 1]
    LB --> S2[Server 2]
    LB --> S3[Server 3]
```

#### Pros

* Highly scalable
* Fault tolerant
* Industry standard

#### Cons

* Requires stateless services
* More complexity

---

### Interview Gold Line â­

> Horizontal scaling is preferred for large-scale distributed systems.

---

## 1.2.4 Load: What Are We Scaling For?

### Common Load Metrics

| Metric           | Meaning             |
| ---------------- | ------------------- |
| QPS / RPS        | Requests per second |
| Concurrent users | Active users        |
| Data size        | Storage growth      |
| Traffic pattern  | Spikes vs steady    |

### Example

```
1M users
10 requests/user/day
â‰ˆ 115 RPS
```

---

## 1.2.5 Read vs Write Heavy Systems â­â­â­â­

### Read-Heavy

* Many reads
* Fewer writes

Examples:

* Social media feeds
* Product catalogs

### Write-Heavy

* Many writes

Examples:

* Logging systems
* Analytics ingestion

### Design Impact

* Read-heavy â†’ caching, replicas
* Write-heavy â†’ sharding, async writes

---

## 1.2.6 Bottlenecks (MOST IMPORTANT)

A **bottleneck** is the first thing that breaks under load.

### Common Bottlenecks

* Database
* Network
* CPU
* Disk I/O
* Locks

```mermaid
graph LR
    Client --> Service --> DB[(Database)]
```

> In most systems, **the database is the first bottleneck**.

---

## 1.2.7 Single Point of Failure (SPOF)

### What is SPOF?

A component whose failure brings down the system.

### Example

* Single DB
* Single server

```mermaid
graph TD
    App --> DB[(Single DB)]
```

### Fix

* Replication
* Redundancy

---

## 1.2.8 Scaling Stateless Services â­â­â­â­â­

Stateless services:

* Store no client state
* Can be scaled horizontally easily

```mermaid
graph LR
    LB --> S1
    LB --> S2
    LB --> S3
```

### Why Interviewers Love This

* Easy to explain
* Industry best practice

---

## 1.2.9 Scaling Stateful Components (Hard Part)

### Databases Are Stateful

* Cannot just add DBs randomly

Scaling strategies:

* Read replicas
* Sharding
* Caching

```mermaid
graph LR
    App --> PrimaryDB
    App --> ReplicaDB
```

> Databases scale **differently** than services.

---

## 1.2.10 Scale vs Performance vs Availability

These are related but different.

| Concept      | Meaning       |
| ------------ | ------------- |
| Performance  | How fast      |
| Scalability  | How much load |
| Availability | How often up  |

Example:

* A fast system can still crash under load
* A scalable system may have higher latency

---

## 1.2.11 Over-Scaling vs Under-Scaling

### Over-Scaling

* Too many components
* High cost
* Complex

### Under-Scaling

* System crashes
* Poor user experience

### Interview Insight â­

> Start simple, scale incrementally.

---

## 1.2.12 Real Example: Login System Scaling

### Initial Design

```mermaid
graph LR
    User --> App --> DB
```

### Scaled Design

```mermaid
graph LR
    User --> LB
    LB --> App1
    LB --> App2
    App1 --> DB
    App2 --> DB
```

Next bottleneck?
ğŸ‘‰ Database â†’ solved later with caching & replicas.

---

## Key Takeaways â­â­â­â­â­

* Scalability â‰  performance
* Horizontal scaling is preferred
* Bottlenecks appear one-by-one
* Databases are hardest to scale
* Stateless services enable scale

---

## Interview-Ready One-Liners â­

* â€œWe scale services horizontally.â€
* â€œThe database is the main bottleneck.â€
* â€œStateless services enable easy scaling.â€
* â€œScaling is about handling growth, not speed.â€

---

## References & Deep-Dive Resources

### Articles

* [https://www.geeksforgeeks.org/scalability-in-system-design/](https://www.geeksforgeeks.org/scalability-in-system-design/)
* [https://www.cloudflare.com/learning/performance/what-is-scalability/](https://www.cloudflare.com/learning/performance/what-is-scalability/)
* [https://aws.amazon.com/what-is/scalability/](https://aws.amazon.com/what-is/scalability/)

### Videos

* [https://www.youtube.com/watch?v=HhK4J6V6qYk](https://www.youtube.com/watch?v=HhK4J6V6qYk) (Scalability Explained)
* [https://www.youtube.com/watch?v=E8vS0xNqzXU](https://www.youtube.com/watch?v=E8vS0xNqzXU) (Vertical vs Horizontal Scaling)

### Books

* *Designing Data-Intensive Applications*
* *System Design Interview â€“ Alex Xu*
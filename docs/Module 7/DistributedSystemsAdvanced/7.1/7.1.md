---
title: Time & Ordering Problems
sidebar_label: "7.1 Time & Ordering Problems"
description: Understanding clock skew, logical clocks, and ordering challenges in distributed systems
---

# Time & Ordering Problems

> Goal: Understand why time is unreliable in distributed systems and how ordering of events is handled without trusting physical clocks.

---

## 7.1.1 Why Time Is Hard in Distributed Systems ⭐⭐⭐⭐⭐

In a single machine:
- One clock
- Events are sequential
- Ordering is easy

In distributed systems:
- Multiple machines
- Each has its own clock
- Network delays exist
- Messages arrive out of order

> There is no global clock in distributed systems.

---

## 7.1.2 Clock Skew ⭐⭐⭐⭐⭐

### What Is Clock Skew?

Clock skew occurs when:
- Different machines have slightly different system times.

Example:

Server A time: 10:00:01  
Server B time: 09:59:58  

Even a few milliseconds difference can cause issues.

---

## 7.1.3 Why Clock Skew Is Dangerous

Problems caused by clock skew:

- Incorrect event ordering
- Authentication token expiry issues
- Inconsistent logs
- Conflict resolution problems

Example:
- Payment recorded before order creation (due to time difference)

---

## 7.1.4 Network Delay Complicates Ordering

Even if clocks were synchronized:

- Network latency is unpredictable
- Message may arrive late
- Events processed out of order

```mermaid
sequenceDiagram
    A->>B: Event1
    A->>B: Event2
    Note right of B: Event2 arrives before Event1
````

> Arrival order ≠ actual event order.

---

# 7.1.5 Physical Clocks vs Logical Clocks ⭐⭐⭐⭐⭐

## Physical Clock

* Based on real-world time (UTC)
* Subject to skew
* Synchronized via NTP
* Not perfectly reliable

---

## Logical Clock

* Does not rely on real time
* Tracks causal relationships
* Used to determine event ordering

> Logical clocks solve ordering without trusting real time.

---

# 7.1.6 Lamport Logical Clocks (Basic Idea) ⭐⭐⭐⭐

Proposed by Leslie Lamport.

Each process maintains a counter.

Rules:

1. Increment counter before each event.
2. When sending message → attach timestamp.
3. On receiving message:

   * Set counter = max(local, received) + 1.

---

### Example

```mermaid
sequenceDiagram
    A->>A: Event (1)
    A->>B: Send (2)
    B->>B: Receive (max(0,2)+1 = 3)
```

This ensures:
If event A happened before event B,
then timestamp(A) < timestamp(B).

---

## Limitation

Lamport clocks ensure ordering but:

* Cannot detect concurrent events.

---

# 7.1.7 Concurrent Events ⭐⭐⭐⭐

Two events are concurrent if:

* Neither happened before the other.
* No causal relationship exists.

Example:

* Two users update different records simultaneously.

Lamport timestamps cannot always detect concurrency clearly.

---

# 7.1.8 Why Ordering Matters in System Design

Ordering is critical in:

* Financial transactions
* Distributed logs
* Event sourcing
* Replication systems
* Distributed databases

Incorrect ordering can cause:

* Double spending
* Lost updates
* Data corruption

---

# 7.1.9 Real-World Example (Payment System)

Scenario:

1. User updates address.
2. User places order.
3. Due to network delay, order processed first.

System must ensure:
Address update logically happened before order.

Logical ordering prevents inconsistency.

---

# 7.1.10 Common Interview Mistakes ❌

❌ Assuming all servers share same time
❌ Ignoring network delays
❌ Confusing physical time with event ordering
❌ Not mentioning logical clocks

✅ Correct thinking:

* No global clock exists
* Network delay affects ordering
* Use logical clocks to track causality

---

# Key Takeaways ⭐⭐⭐⭐⭐

* Time cannot be trusted in distributed systems
* Clock skew is unavoidable
* Arrival order ≠ event order
* Logical clocks solve ordering issues
* Lamport clocks track causal relationships

---

# Interview-Ready One-Liners ⭐

* “There is no global clock in distributed systems.”
* “Clock skew causes ordering issues.”
* “Arrival order does not imply causality.”
* “Logical clocks help establish happens-before relationships.”
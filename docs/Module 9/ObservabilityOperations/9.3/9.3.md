---
title: Distributed Tracing
sidebar_label: "9.3 Distributed Tracing"
description: Understanding why distributed tracing is needed and how it provides request flow visibility in microservices
---

# Distributed Tracing

> Goal: Understand how distributed tracing helps track a request across multiple services and diagnose latency and failures.

---

# 9.3.1 Why Distributed Tracing Is Needed ⭐⭐⭐⭐⭐

In monolithic systems:
- One request → One process
- Easy to trace execution

In microservices:
- One request → Multiple services
- Calls may be synchronous or asynchronous
- Hard to identify bottlenecks

Logs alone are not enough.

> Distributed tracing provides end-to-end request visibility.

---

# 9.3.2 What Is Distributed Tracing?

Distributed tracing tracks:

- A single request
- Across multiple services
- From entry to completion

It shows:
- Call sequence
- Latency per service
- Failure points

---

# 9.3.3 Key Concepts ⭐⭐⭐⭐⭐

## 1. Trace

Represents entire request journey.

Example:
User → API Gateway → Payment Service → DB → Fraud Service

---

## 2. Span

Represents a single unit of work within a trace.

Each service call = one span.

---

## 3. Trace ID

Unique ID for entire request.

---

## 4. Span ID

Unique ID for each operation within trace.

---

```mermaid
graph TD
    Client --> API
    API --> PaymentService
    PaymentService --> DB
    PaymentService --> FraudService
````

All connected by same Trace ID.

---

# 9.3.4 How Tracing Works ⭐⭐⭐⭐

1. Generate Trace ID at entry point.
2. Pass Trace ID in headers.
3. Each service creates span.
4. Spans collected and visualized.

Example header:

```
trace-id: abc123
```

---

# 9.3.5 What Problems Tracing Solves ⭐⭐⭐⭐⭐

* Identify slow services
* Detect dependency bottlenecks
* Debug request failures
* Understand service interactions
* Diagnose cascading latency

---

# 9.3.6 Example: Payment Request Flow ⭐⭐⭐⭐⭐

Scenario:

User makes payment.

Trace shows:

* API Gateway: 10ms
* Payment Service: 50ms
* Fraud Service: 900ms
* DB: 20ms

Clearly:
Fraud service causing delay.

Without tracing:
Hard to identify.

---

# 9.3.7 Tracing vs Logging vs Metrics ⭐⭐⭐⭐⭐

| Feature      | Logs           | Metrics           | Tracing            |
| ------------ | -------------- | ----------------- | ------------------ |
| Detail Level | Event-level    | Aggregated        | Request-level      |
| Use Case     | Debugging      | Health monitoring | Latency root cause |
| Scope        | Single service | System-level      | Cross-service      |

> All three together provide full observability.

---

# 9.3.8 Sampling ⭐⭐⭐⭐

Tracing every request is expensive.

Solution:

* Sample subset of requests.
* Trace only slow/error requests.
* Adaptive sampling strategies.

---

# 9.3.9 Distributed Tracing in Real Systems

Common tools:

* OpenTelemetry
* Jaeger
* Zipkin
* Cloud tracing systems

Used in:

* Microservices architectures
* Large-scale systems
* Performance debugging

---

# 9.3.10 Common Interview Mistakes ❌

❌ Confusing logs with tracing
❌ Ignoring trace ID propagation
❌ Forgetting sampling
❌ Not explaining spans

✅ Correct thinking:

* Trace tracks entire request
* Span represents unit of work
* Trace ID must propagate
* Use sampling for efficiency

---

# Key Takeaways ⭐⭐⭐⭐⭐

* Tracing provides end-to-end visibility
* Trace ID connects services
* Spans measure service latency
* Essential for microservices debugging
* Works alongside logs and metrics

---

# Interview-Ready One-Liners ⭐

* “Tracing shows the full request journey.”
* “Trace ID must propagate across services.”
* “Spans represent individual operations.”
* “Tracing identifies latency bottlenecks.”

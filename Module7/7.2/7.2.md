---
title: Distributed Locks
sidebar_label: "7.2 Distributed Locks"
description: Understanding why distributed locks are needed and the problems with naive locking in distributed systems
---

# Distributed Locks

> Goal: Understand why distributed locks are required in distributed systems and the challenges of implementing them correctly.

---

## 7.2.1 Why Distributed Locks Are Needed ⭐⭐⭐⭐⭐

In a single machine:

- Use a mutex
- Lock a resource
- Safe access guaranteed

In distributed systems:

- Multiple servers
- Shared resources
- No shared memory
- No central authority

> Local locks do NOT work across machines.

---

## 7.2.2 Real-World Problem Example ⭐⭐⭐⭐⭐

Scenario:

- Two servers process the same order.
- Both try to update inventory.
- Without coordination → double deduction.

```mermaid
sequenceDiagram
    ServerA->>DB: Deduct Inventory
    ServerB->>DB: Deduct Inventory
````

Result:
Inventory becomes inconsistent.

We need:

> Only one server should update at a time.

---

## 7.2.3 What Is a Distributed Lock?

A distributed lock:

* Ensures only one node can access a shared resource at a time.
* Works across multiple machines.

Properties:

* Mutual exclusion
* No deadlocks
* Fault tolerance

---

## 7.2.4 Naive Locking Problems ⭐⭐⭐⭐⭐

### 1️⃣ Using Database Row as Lock

Example:

```
UPDATE lock_table SET locked=true WHERE id=1;
```

Problems:

* What if server crashes after acquiring lock?
* Lock may remain forever.
* Causes deadlock.

---

### 2️⃣ Using In-Memory Variable

Each server has its own memory.

Not shared → Not reliable.

---

## 7.2.5 Key Challenges in Distributed Locks ⭐⭐⭐⭐⭐

1️⃣ Network partitions
2️⃣ Process crashes
3️⃣ Clock skew
4️⃣ Lock expiration issues
5️⃣ Split-brain problems

---

## 7.2.6 Lock Expiry (Very Important) ⭐⭐⭐⭐

To avoid deadlock:

* Locks must have TTL (expiration time).
* If process crashes → lock auto-expires.

Example:

```
Lock key expires after 10 seconds.
```

But:

* What if process is still working when TTL expires?
* Another server may acquire lock.
* Leads to race conditions.

---

## 7.2.7 Redlock (Conceptual Overview) ⭐⭐⭐⭐

Used with Redis.

Idea:

* Acquire lock on majority of nodes.
* Only consider lock valid if majority success.
* Add expiry time.

Improves fault tolerance but adds complexity.

---

## 7.2.8 Zookeeper / etcd-Based Locks ⭐⭐⭐⭐

Use consensus-based systems.

Advantages:

* Stronger consistency
* More reliable lock ownership
* Leader-based coordination

More complex but safer.

---

## 7.2.9 Distributed Lock Use Cases

* Inventory update
* Leader election
* Scheduled jobs
* Prevent duplicate payment processing
* Resource coordination

---

## 7.2.10 When NOT to Use Distributed Locks ⭐⭐⭐⭐

Avoid when:

* System can be designed idempotent
* Eventual consistency acceptable
* Conflict resolution possible

> Locks reduce scalability.

---

## 7.2.11 Example: Payment System

Use distributed lock for:

* Preventing double charge
* Ensuring one transaction per order

But better solution:

* Use idempotency keys
* Use unique constraints in DB

Locks should be last resort.

---

## 7.2.12 Common Interview Mistakes ❌

❌ Suggesting in-memory lock
❌ Ignoring lock expiry
❌ Not handling crash scenarios
❌ Assuming distributed locks are simple

✅ Correct thinking:

* Locks must handle crashes
* TTL required
* Network partitions complicate locking
* Prefer idempotency when possible

---

## Key Takeaways ⭐⭐⭐⭐⭐

* Local locks don’t work in distributed systems
* Distributed locks ensure mutual exclusion
* TTL required to avoid deadlocks
* Network partitions complicate locking
* Locks reduce scalability

---

## Interview-Ready One-Liners ⭐

* “Local mutex doesn’t work across machines.”
* “Locks must have expiration.”
* “Distributed locks are complex and risky.”
* “Prefer idempotency over locking.”